-- Esercizio 1
-- Creazione tabelle
create table E1 (
	K1	INT NOT NULL PRIMARY KEY,
	A	INT NOT NULL,
    K2R1	INT NOT NULL,
    C	INT NOT NULL
);

create table E2 (
	K2 	INT NOT NULL PRIMARY KEY,
    B1 	INT,
    B2 	INT,
    K2Y 	INT NOT NULL REFERENCES E2,
    K1R2 	INT REFERENCES E1,
    CONSTRAINT B CHECK (
		(B1 IS NULL AND B2 IS NULL)
	 		OR
	 	(B1 IS NOT NULL AND B2 IS NOT NULL)
	),
	CONSTRAINT NO_SELF_REF CHECK (
		K1R2 IS NULL OR K2 <> K2Y
	)
);

-- Vincoli
ALTER TABLE E1
ADD CONSTRAINT K2R1 FOREIGN KEY (K2R1) REFERENCES E2;

-- Trigger
CREATE OR REPLACE TRIGGER E2_B_KEY
BEFORE INSERT ON E2
REFERENCING NEW AS N
FOR EACH ROW
WHEN (
	EXISTS (
		SELECT 	*
		FROM	E2
		WHERE	(B1, B2) = (N.B1, N.B2)
	)
)
SIGNAL SQLSTATE '70001' ('La coppia (B1, B2) è una chiave per E2, quando non ha valori nulli');

CREATE OR REPLACE TRIGGER NO_R2_AND_R3Y
BEFORE INSERT ON E2
REFERENCING NEW AS N
FOR EACH ROW
WHEN (
	EXISTS (
		SELECT	*
		FROM	E2
		WHERE	K2 = N.K2Y
		AND		K1R2 IS NOT NULL
	)
)
SIGNAL SQLSTATE '70002' ('Una istanza di E2 che partecipa a R2 non può partecipare a R3 con ruolo Y');


-- Esercizio 2
-- Creazione tabelle
create table E1 (
	K1 	INT not NULL PRIMARY KEY,
	A 	INT not null,
	D 	INT,
	K1X INT REFERENCES E1,
	K1E2	INT,
	B 	INT,
	CONSTRAINT COEX CHECK (
		(K1X IS NULL AND K1E2 IS NULL AND B IS NULL AND D IS NULL)
			OR
		(K1X IS NOT NULL AND K1E2 IS NOT NULL AND B IS NOT NULL AND D IS NOT NULL)
	),
	CONSTRAINT FKR2 FOREIGN KEY (K1E2, B) REFERENCES E2,
	CONSTRAINT DIVERSIR2 CHECK (
		K1 <> K1X AND K1X <> K1E2 AND K1E2 <> K1
	)
);

create table E2 (
	K1 	INT not null,
	B 	INT not null,
	C 	INT not null,
	PRIMARY KEY (K1, B)
);

-- Vincoli
ALTER TABLE E2
ADD CONSTRAINT K1R1 FOREIGN KEY (K1) REFERENCES E1;

-- Trigger
CREATE OR REPLACE TRIGGER CHECKSUM
BEFORE INSERT ON E2
REFERENCING NEW AS N
FOR EACH ROW
WHEN (
	100 > N.B + (
		SELECT COALESCE(SUM(B), 0)
		FROM 	E2
		WHERE	K1 = N.K1	
	)
)
SIGNAL SQLSTATE '70001' ('La tupla inserita ha un valore di B troppo grande! Ridurlo o cambiare la tupla di E1 che la identifica');


-- Esercizio 3
-- Creazione tabelle
create table E1 (
	K1	INT NOT NULL PRIMARY KEY,
	A	INT NOT NULL,
	E3_C	INT,
	E2_K2	INT,
	E2_B	INT,
	E3_K1	INT REFERENCES E4,
	E2	INT,
	E3	INT,
	CONSTRAINT GERARCHIA CHECK (
		(E2 IS NULL AND E3 IS NOT NULL)
			OR
		(E2 IS NOT NULL AND E3 IS NULL)
	),
	CONSTRAINT COEX_E2 CHECK (
		(E2 IS NOT NULL AND E2_B IS NOT NULL AND E2_K2 IS NOT NULL)
        	OR
        (E2 IS NULL AND E2_B IS NULL AND E2_K2 IS NULL)
	),
	CONSTRAINT COEX_E3 CHECK (
		(E3 IS NOT NULL AND E3_C IS NOT NULL AND E3_K1 IS NOT NULL)
        	OR
		(E3 IS NULL AND E3_C IS NULL AND E3_K1 IS NULL)
	)
);

create table E4 (
  K1  INT NOT NULL PRIMARY KEY,
  D INT NOT NULL
);

-- Vincoli
ALTER TABLE E4
ADD CONSTRAINT K1FK FOREIGN KEY (K1) REFERENCES E1;

-- Trigger
CREATE OR REPLACE TRIGGER E2_K2_CHIAVE
BEFORE INSERT ON E1
REFERENCING NEW AS N
FOR EACH ROW
WHEN (
	EXISTS (
		SELECT	*
		FROM	E1
		WHERE	E2_K2 = N.E2_K2
	)
)
SIGNAL SQLSTATE '70001' ('La tupla inserita ha un valore di E2_K2 già presente');

CREATE OR REPLACE TRIGGER E4_REF_E2
BEFORE INSERT ON E4
REFERENCING NEW AS N
FOR EACH ROW
WHEN (
	NOT EXISTS (
		SELECT	*
		FROM	E1
		WHERE	K1 = N.K1
		AND		E2 IS NOT NULL
	)
)
SIGNAL SQLSTATE '70002' ('Ogni istanza di E4 deve essere anche istanza di E2');
